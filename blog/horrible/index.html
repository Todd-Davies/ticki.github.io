<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.16" />


<title>Rust&#39;s `std::collections` is absolutely horrible - Ticki</title>
<meta property="og:title" content="Rust&#39;s `std::collections` is absolutely horrible - Ticki">



  






<link rel="stylesheet" href="/css/main.css" media="all">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400|Lato:400,400italic,700">

  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo"><img src="/images/logo.png" width="50" height="50"></a>

  <ul class="nav-links">
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="https://github.com/ticki">GitHub</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    

    <h1 class="article-title">Rust&#39;s `std::collections` is absolutely horrible</h1>

    

    <div class="article-content">
      

<p>Rust is by far my favorite language, and I am very familiar with it, but there is one aspect that annoys me a lot: <code>std::collections</code>, a part of the opt-out standard library.</p>

<p>This post (with a rather edgy title) will go through the short-fallings of the API and implementation of <code>std::collections</code>.</p>

<p><strong>Update</strong>: The title was previously &ldquo;Why <code>std::collections</code> is absolutely horrible&rdquo;. It was in the hope to spark critical discussion, however people were rather annoyed by this title (and I understand why), so I changed it to something less provocative.</p>

<h1 id="what-it-contains">What it contains</h1>

<p><code>std::collections</code> has a rather small set of collections (which is a legitimate choice to make to preserve minimality), the catch being that it&rsquo;s an odd choice of collections:</p>

<ol>
<li>B-tree based map and set.</li>
<li>Binary heap.</li>
<li>Hash table and set.</li>
<li>Doubly-linked list.</li>
<li>Ring buffer.</li>
<li>Random-acess vectors (strictly speaking not in <code>std::collections</code> but instead in <code>std::vec</code>).</li>
</ol>

<p>That seems fine, doesn&rsquo;t it? No, it doesn&rsquo;t. If you consider what it lacks of these are very weird choices of structures.</p>

<p>Take binary heap. It is incredibly useful at times, but is it really fit for a standard library with focus on being minimal? Let&rsquo;s look at the statistics:</p>

<p>444 examples of usage of this structure (in Rust) on GitHub. Now, we obviously cannot be sure that this sample is representative, but it should give a pretty good insight on the usage.</p>

<p>Looking through these, approximately 50 of these are tests of <code>BinaryHeap</code> itself. Another 50 are reimplementations of it. Around 100 of them are duplicates of other codes (e.g. downloaded libraries). This leaves us with around 250 usages, and that&rsquo;s only slightly more than the incredibly useful <code>VecMap</code>, which isn&rsquo;t even in the standard library!</p>

<p>If minimalism really is a goal (which I am going to criticise in a minute), it seems rather weird to have a collection which is barely used more than a non-libstd collection.</p>

<p>Let&rsquo;s move on to doubly-linked list. Searching on GitHub gives you 534 results. I was unable to find <em>a single place where it was used in a manner that could not be replaced by singly-linked lists</em>. Chances are that there are some, but they&rsquo;re incredibly rare, and it is odd given that there are no singly-linked list structures in the standard libraries.</p>

<p><strong>Update</strong>: To clarify here. I&rsquo;m not arguing that the primitives I propose later deserves a place above these, rather that for a minimal set of collections, the choice is rather odd, given that some collections are even more common than some of these.</p>

<h1 id="what-it-doesn-t-contain">What it doesn&rsquo;t contain</h1>

<h2 id="concurrent-data-structures">Concurrent data structures</h2>

<p>The whole standard library contains exactly two concurrent data structures (note that data structures are different from containers), namely the MPSC-queues (the blocking queue with a limited buffer and the non-blocking with an unlimited buffer). These are used for cross-thread message passing and the alike.</p>

<p>But where are all the other concurrent primitives?</p>

<p>People tend to wrap their structure in <code>Mutex</code>, like <code>Mutex&lt;HashMap&lt;...&gt;&gt;</code>, but that is often an order of magnitude slower than a concurrent hash table.</p>

<p>Then there&rsquo;s the multithreaded push/pop stacks (as opposed to the queue/unqueue lists), and so on.</p>

<p>There are quite a few implementations of structures as the ones described above, but they are more often than not poorly implemented. The leading library (which has a pretty good implementation quality) is <a href="https://github.com/aturon/crossbeam">crossbeam</a>, but unfortunately it only implements a very limited set of synchronization primitives (no maps, no tables, no skip lists, etc.).</p>

<h2 id="singly-linked-lists">Singly linked lists</h2>

<p>I&rsquo;ve already mentioned this, but singly linked list are often useful.</p>

<h2 id="priority-queues">Priority queues</h2>

<p>Priority queues is the structure everyone ask about and looks for, but no one can name it (here&rsquo;s an exercise: go on Google and try to vaguely describe this structure, you will for sure find at least one thread asking for exactly that description, and often no one is able to answer the question or misguidedly proposes binary heaps instead).</p>

<p>Say you have an ordered list of elements, each of which has a priority. Now, you want to be able to retrieve the element with the highest or the lowest priority, with a reasonable performance. Note that mere heaps are not sufficient, since they are not arbitrarily ordered.</p>

<p><strong>Update</strong>: People think I&rsquo;m talking about binary heaps, but they&rsquo;re fundamentally very different. A priority queue is some arbitrarily ordered list (or map) such that elements with high or low priority can be retrieved quickly. Binary heaps are not associative arrays or lists, they do not allow ordering of the elements, and are thus conceptually simpler than priority queues. Note that priority queues are almost always implemented with binary heaps as the backbone.</p>

<p>Priority queues are used everywhere from cache level regulation to efficient scheduling, and are in my opinion one of the most useful data structures of all.</p>

<p>It is hard to find out exactly how much it is used in the Rust community, given its many names and reimplementations. Only 83 occurrences of the name &ldquo;PriorityQueue&rdquo; in Rust code can be found on GitHub, but I suspect the real number to be much higher.</p>

<h2 id="treaps">Treaps</h2>

<p>Treaps are generally faster than other self-balanced trees (on the average), but the really killer feature is the bulk operations. These are highly efficient algorithms for union, intersections, and set differences.</p>

<p>When the programmer is manipulating sets like this (union, intersections, and so on) and iterators aren&rsquo;t sufficient (i.e., it is for storage, not iteration), these can be incredibly useful as a high-performance data structure.</p>

<h2 id="skip-lists">Skip lists</h2>

<p>Skip lists are more niche than the structures described above, but they have excellent performance characteristics.</p>

<p>Skip lists are conceptually similar to N-ary trees, but in the representation of a list. They&rsquo;re a probabilistic data structure, which holds a list and some number of sublists such that the <em>n</em>&lsquo;th sublist is a sublist of the <em>n - 1</em>&lsquo;th sublist. Search can be visualized as binary search by observing how two paths can be taken: A) go to the next sublist B) follow the link.</p>

<p>The reason a good implementation outperforms a good implementation of classical binary search trees has to do with two reasons:</p>

<ol>
<li><p>On average, 50% of the links followed under a search are cache local, whereas B-trees, for example, are around 0% cache local.</p></li>

<li><p>No tree rotations or equivalent operations are needed during insertion.</p></li>
</ol>

<p>The downside is that they are not as rigidly balanced, making them slower in some cases.</p>

<h2 id="self-balancing-trees">Self-balancing trees</h2>

<p>As mentioned, Rust&rsquo;s standard library already has an excellent implementation of B-trees, a popular form of self-balancing trees.</p>

<p>The other popular self-balancing trees are good candidates as well (AVL and LLRB/Red-black). While they do essentially the same, they can have very different performance characteristics, and switching can influence the program&rsquo;s performance vastly.</p>

<p>Having a diverse set of such structures can be good, especially if the documentation details which one to use based on your use case.</p>

<h2 id="slobs-aka-pointer-lists-memory-pools-typed-arenas-etc">SLOBs (aka. pointer lists, memory pools, typed arenas, etc.)</h2>

<p>This is a very simple, and yet very powerful, data structure. In fact, they are nothing but a glorified singly linked list of pointers to some type. The dealbreaker is the fact that it requires no storage aside from the data it holds.</p>

<p>That is, no allocation is needed to push and pop pointers from this list. This is possible by letting the data which is inactive hold the list itself.</p>

<p>So what&rsquo;s the big deal here? It turns out to be extremely useful for region-based memory management. If you have a lot of allocations of the same type, it is often multiple orders of magnitude faster than allocating each of them seperately, and what&rsquo;s even cooler is the data locality it provides: Since it is based on one big contagious segment broken down into pieces, it will only cover a few pages, and consequently it is cache efficient (this fact will be abused in a minute).</p>

<h1 id="we-can-just-leave-it-to-other-libraries">&ldquo;We can just leave it to other libraries&rdquo;</h1>

<p>A common talking point is that we can simply outsource it to external libraries. Unfortunately, they cannot provide an essential property of the standard library: standardization. Standard libraries serves for making sure t
he ecosystem is uniform. If something is crucial for keeping the ecosystem together, it deserves a place in the standard library. These are severely underused due to the stigma around adding new dependencies.</p>

<p>Standardization is absolutely crucial for adaptation.</p>

<h1 id="criticizing-the-structures-it-do-have">Criticizing the structures it do have</h1>

<h2 id="hashmap"><code>HashMap</code></h2>

<p>Rust&rsquo;s hash table implementation is perhaps the worst part, not because it is particularly bad in context, but because it is a very performance-critical component, and yet has serious flaws.</p>

<p>A quick overview of the Rust <code>HashMap</code>/<code>HashSet</code> implementation is:</p>

<ul>
<li>Open addressing (Robin Hood hashing)</li>
<li>90.9% load factor before reallocation</li>
<li>Defaults to Sip-hasher (cryptographic hash function)</li>
</ul>

<p>Let&rsquo;s just go through these one-by-one and see what&rsquo;s wrong:</p>

<h3 id="robin-hood-hashing">Robin Hood hashing</h3>

<p>Robin Hood hashing is a double-hashing variant quite, in which you rehash until the slot is free. Robin Hood hashing improves plain double-hashing by making sure the slots occupants are ordered by the probe length.</p>

<p>So what&rsquo;s the problem here? Well, the cache efficiency is not exactly ideal, but we get freedom from clustering in return.</p>

<p>The &ldquo;opposite&rdquo; approach is linear probing (where you add some constant - often 1 - to the slot number until it is free), which has the opposite nature: Cache efficiency is really good, but it is very sensitive to clustering.</p>

<p>A reasonable alternative which takes the best of each of these solutions is quadratic probing, which simply uses a quadratic polynomial to jump between slots (or, in analogy to the one given above, the constant in question increases linearly).</p>

<p>In most scenarios (especially for large tables), quadratic probing has fewer cache misses, due to better data locality.</p>

<p>There&rsquo;s no reason to have strong opinions on this subject. The difference is rather small, but interesting nonetheless.</p>

<h3 id="a-high-reallocation-threshold">A high reallocation threshold</h3>

<p>This mostly comes down to a trade-off between between memory and CPU. If you think about it, 1:9 empty slots is a pretty dense table with an average probe length of 6 rehashes. Potentially (for very large tables) that can lead to 6 cache misses for just a single lookup.</p>

<p>The advantage is that it is relatively memory efficient, but that should really only be a concern for really big tables. For most tables, this is way too high, and it trades CPU cycles for memory (which is almost unimportant these days).</p>

<p>I personally think that having a constant factor is a bad idea. I think it should be some function of the number of elements in the table, such that the factor is lower for small tables (where memory isn&rsquo;t a concern). This way you get memory efficiency when it matters.</p>

<h3 id="sip-hasher">Sip-hasher?!?</h3>

<p>Sip-hasher is a cryptographic hash function, and as with most cryptographic hash functions, it is slower than the non-cryptographic counterpart.</p>

<p>And it doesn&rsquo;t even have a measurable better quality. I tried giving three different hash functions various data sets. Collision-wise they did equally on every data set, with exception of the English dictionary (as seen below). In every single test, my home-made hash function &ldquo;long hasher&rdquo; beats sip-hasher on performance <em>by a significant factor</em> (around 30%)&hellip;</p>

<pre><code>~ SipHasher
    Filled buckets: 2048
    Max bucket: 245
    Time: 0 s. 39232 ms.
    GB/s: 0.8565382742517557
~ DJB2
    Filled buckets: 2048
    Max bucket: 238
    Time: 0 s. 39463 ms.
    GB/s: 0.784737479297558
~ LongHasher
    Filled buckets: 2048
    Max bucket: 239
    Time: 0 s. 29562 ms.
    GB/s: 4.95375004585191
</code></pre>

<p>Some investigation shows that the vast majority (98%) of the time of retrieval is used on hashing (it&rsquo;s not clear if the same is true for insertions, but it still have a major influence)). Say you used hash maps for caching database queries. That could potentially translate to 30% faster retrieval on cached queries.</p>

<p>My point isn&rsquo;t that LongHasher is fantastic, but my point is that there are hash functions which vastly beats sip hasher performance-wise.</p>

<p>On a side note: These numbers are quite impressive, and if you don&rsquo;t believe me <a href="https://gist.github.com/anonymous/3b0b489137af9006d5c498f10d42514a">you can run it yourself</a>. The reason that long hasher is able to outperform them both is that it consumes eight bytes at once. Otherwise, it is really just multiplying by a prime, adding some constant, multiplying by another byte, rotating right and then XORing by some key.</p>

<p>Now, if it isn&rsquo;t quality, then what&rsquo;s the reason for using a cryptographic hash function? One reason often cited is Denial-of-Service resistance, and that&rsquo;s a valid concern, but is it really something that everyone should pay for?</p>

<p>You may know the famous &ldquo;What you don&rsquo;t use, you don&rsquo;t pay for&rdquo; idiom. This is a core part of the &ldquo;abstraction without overhead&rdquo; principle. It is relatively rare to actually need DoS-protection, and you pay for this whenever you use <code>HashMap</code> without overwriting the hash function.</p>

<p>And, ignoring that point for a moment, The idea that your code is &lsquo;secure by default&rsquo; is a dangerous one and promotes ignorance about security. You code is <em>not</em> secure by default.</p>

<p>If you really do need a fast and yet secure hash function, Sip-hasher is a wonderful choice. To be clear, I&rsquo;m not arguing against Sip-hasher (I actually like the function), but rather against having it as a default choice.</p>

<h2 id="btreemap"><code>BTreeMap</code></h2>

<p><code>BTreeMap</code> and <code>BTreeSet</code> are generally a good implementation. My only criticism has to do with cache efficiency, which is notoriously bad. In fact, around 60% of the links followed leads to cache misses. For a map 1000 elements, a lookup would result in approximately 6 cache misses. For 10000, the number is 8.</p>

<p>These can be quite expensive. A solution is proposed in the section about &ldquo;Cache-efficient structures&rdquo;.</p>

<h2 id="vecdeque"><code>VecDeque</code></h2>

<p><code>VecDeque</code> is a decent implementation. The only problem is that you cannot range index (slice) it. This is due to the very nature of ring buffers.</p>

<p>An alternative to conventional ring buffers is <a href="http://www.codeproject.com/Articles/3479/The-Bip-Buffer-The-Circular-Buffer-with-a-Twist">biparite buffers</a>, which has essentially the same performance, but allows this (and other interesting) API.</p>

<h2 id="mpsc">MPSC</h2>

<p>MPSC is a popular tool for message passing, but a critical point is often overlooked: Every queuing/dequeueing involves a malloc call. That sounds pretty bad, doesn&rsquo;t it?</p>

<p>MPSC is supposed to be lock-less, but that isn&rsquo;t the case if the tcache is empty. Then it involves a lock.</p>

<p>Since you effectively queue and dequeue all of the time, you actually waste allocations going in and out the allocator. That&rsquo;s a major overhead, and totally unreflected in the API, giving an illusion of zero-cost.</p>

<p>And, it turns out that it isn&rsquo;t necessary. Because of the ring-buffer-like structure of MPSC, you can effectively store it all in a concurrent SLOB list, making malloc calls incredibly rare (ideally only upon the first queue).</p>

<p>My benchmarks I&rsquo;ve made on <a href="https://github.com/redox-os/ralloc">ralloc</a>, a memory allocator I wrote, (which uses mpsc internally for cross-thread frees) shows a significant performance gain. An exercise for the reader is to do the same for Servo and try to see if it affects performance.</p>

<h2 id="vec"><code>Vec</code></h2>

<p>My criticism of <code>Vec</code> is the lack of API for manual management. One particular missing thing is the ability to replace the reallocation strategy with a custom one.</p>

<p>Vectors are used everywhere and they often have different usage patterns, many of which can be exploited to improve performance and memory efficiency.</p>

<p>Another thing I sometimes need is the ability to get a mutable reference to the element I pushed without needing extra bound checks (note that in most cases this is a trivial optimization for LLVM, but it adds a lot of convenience). This could simply be solved by having <code>push</code> return <code>&amp;mut T</code>. This is technically a breaking change but I doubt it will affect anybody.</p>

<h1 id="cache-efficient-structures">Cache-efficient structures</h1>

<p>I spoke a little about SLOB-based arenas previously. It turns out to have major impact on the cache efficiency, and thereby the performance, of the structure.</p>

<p>The idea is that each structure holds an arena which only spans a few memory pages, ensure data locality. Obviously, this is more memory hunky, but it is conceptually similar to vectors which reserve extra memory to avoid reallocation. In this case, we are looking for avoiding allocation instead.</p>

<p>Depending on what you&rsquo;re doing it affects the performance positively by 3-10% (B-trees), 5-15% (linked lists), or 40-80% (mpsc). Those numbers are quite impressive (especially the last one).</p>

<h1 id="replacing-the-allocator">Replacing the allocator</h1>

<p>Another lacking feature is an <code>Allocator</code> trait, which is intended to be the bound of some generic parameter in all the collections, allowing you to replace the allocator to exploit allocation patterns of the structure.</p>

<p>An RFC for exactly this <a href="https://github.com/rust-lang/rfcs/pull/1398">already exists</a> and is merged, but the implementation is incomplete.</p>

<h1 id="hiding-box">Hiding <code>Box</code></h1>

<p>An unfortunate thing is hiding the overhead by letting the function itself allocate, instead of letting the caller do it. This is (or at least, should be) considered bad style, because the API ought to reflect the semantics and performance characteristics. If the allocation is hidden to the programmer, she might not realize the expensive operations behind the scenes.</p>

<h1 id="the-good-parts">The good parts</h1>

<p>The implementations them self are really good and well-tested. Nothing&rsquo;s wrong there. It is more the implementation and API choices, which are &ldquo;horrible&rdquo;.</p>

    </div>
  </article>

  

</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>

    
  </body>
</html>

